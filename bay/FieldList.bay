/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Widget;

use Runtime.lib;
use Runtime.BaseStruct;
use Runtime.Callback;
use Runtime.ModelProxy;
use Runtime.Web.ApiResult;
use Runtime.Widget.FieldInfo;


struct FieldList extends BaseStruct
{
	Dict fields = {};
	Collection fields_list = [];
	Collection dictionary_list = [];
	Dict dictionary = {};
	Collection primary_keys = [];
	
	
	/**
	 * Add field
	 */
	FieldList addField(FieldInfo field)
	{
		Dict fields = this.fields;
		string field_name = field.name;
		fields <= { field_name } <= field;
		return this.clone{
			"fields": fields,
		}
	}
	
	
	/**
	 * Edit field
	 */
	FieldList editField(FieldInfo field)
	{
		FieldList model = this;
		if (model.fields.has(field.name))
		{
			model <= fields <= { field.name } <= field;
		}
		return model;
	}
	
	
	/**
	 * Set fields
	 */
	FieldList setFields(Dict fields) => this.clone{
		"fields": fields,
	};
	
	
	/**
	 * Returns field by name
	 */
	string getField(string field_name)
	{
		return this.fields.get(field_name);
	}
	
	
	/**
	 * Setup field options
	 */
	FieldList setFieldOptions(string field_name, Collection options)
	{
		Dict fields = this.fields;
		fields <= { field_name } <= options <= options;
		return this.clone{
			"fields": fields,
		}
	}
	
	
	/**
	 * Set fields list
	 */
	FieldList setFieldsList(Collection fields_list) => this.clone{
		"fields_list": fields_list,
	};
	
	
	/**
	 * Remove field from list
	 */
	FieldList removeFieldFromList(string key) => this.clone{
		"fields_list": this.fields_list.removeItem(key)
	};
	
	
	/**
	 * Set primary keys list
	 */
	FieldList setPrimaryKeys(Collection primary_keys) =>
		this.clone({ "primary_keys": primary_keys })
	;
	
	
	/**
	 * Returns primary key
	 */
	Dict getPrimaryKey(Dict item, int pos = 0)
	{
		if (this.primary_keys == null) return pos;
		
		Map keys = new Map();
		for (int i=0; i<this.primary_keys.count(); i++)
		{
			string field_name = this.primary_keys.get(i);
			keys.setValue(field_name, item.get(field_name));
		}
		
		return keys.toDict();
	}
	
	
	/**
	 * Add dictionary field list
	 */
	FieldList addDictionaryField(Dict obj) => this.clone
	{
		"dictionary_list": this.dictionary_list.pushIm(obj)
	};
	
	
	/**
	 * Setup dictionary
	 */
	FieldList setDictionary(string from, Collection items)
	{
		Dict dictionary = this.dictionary;
		dictionary <= { from } <= items;
		return this.clone{
			"dictionary": dictionary,
		}
	}
	
	
	/**
	 * Set dictionary items
	 */
	FieldList setDictionaryItems(string name, Collection items)
	{
		/* Set dictionary */
		Dict dictionary = this.dictionary;
		dictionary <= { name } <= items;
		
		return this.clone{
			"dictionary": dictionary,
		}
	}
	
	
	/**
	 * Update field options
	 */
	static FieldList updateFieldOptions(
		ModelProxy model, Dict dictionary
	)
	{
		string dictionary_name = dictionary["from"];
		string field_name = dictionary["to"];
		Callback filter = dictionary["filter"];
		Callback option = dictionary["option"];
		Collection items = model.data(["dictionary", dictionary_name]);
		
		/* Filter items */
		if (filter != null)
		{
			items = items.filter(
				Dict (Dict item) use (model, filter) => rtl::apply(filter, [model, item])
			);
		}
		
		/* Map items */
		if (option != null)
		{
			items = items.map(
				Dict (Dict item) use (model, option) => rtl::apply(option, [model, item])
			);
		}
		
		/* Sort items */
		items = items.sort(
			int (Dict a, Dict b) => a["label"] > b["label"]
		);
		
		/* Set fields options */
		model.commit("setFieldOptions", field_name, items);
	}
	
	
	/**
	 * Rebuild field options
	 */
	static FieldList rebuildFieldsOptions(ModelProxy model)
	{
		Collection dictionary_list = model.data(["dictionary_list"]);
		if (dictionary_list)
		{
			for (int i=0; i<dictionary_list.count(); i++)
			{
				Dict item = dictionary_list.item(i);
				if (item["auto"] == true)
				{
					model.commit("updateFieldOptions", item);
				}
			}
		}
	}
	
	
	/**
	 * Setup field options from api
	 */
	static void setFieldOptionsFromApi(ModelProxy model, ApiResult api_res, Dict dictionary)
	{
		string from = dictionary["from"];
		Collection items = api_res["data", "dictionary", from];
		
		/* Update dictionary */
		model.commit("setDictionaryItems", from, items);
		
		/* Update options */
		model.commit("updateFieldOptions", dictionary);
	}
	
	
	/**
	 * Set api result
	 */
	static void setApiResult(ModelProxy model, string event, ApiResult res)
	{
		if (res == null) return;
		
		if (
			res.isSuccess() and
			(
				event == "dictionary" or
				event == "item" or
				event == "search"
			)
		)
		{
			Collection dictionary_list = model.data(["dictionary_list"]);
			if (dictionary_list)
			{
				for (int i=0; i<dictionary_list.count(); i++)
				{
					Dict item = dictionary_list.item(i);
					model.commit("setFieldOptionsFromApi", res, item);
				}
			}
		}
	}
	
}