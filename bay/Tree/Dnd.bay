/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2025 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Widget.Tree;

use Runtime.BaseObject;
use Runtime.Widget.Tree.TreeItem;
use Runtime.Widget.Tree.TreeModel;


class Dnd extends BaseObject
{
	const string DRAG_BEFORE = "before";
	const string DRAG_INTO = "into";
	const string DRAG_AFTER = "after";
	
	bool is_drag = false;
	var component = null;
	var drag_elem = null;
	Vector drag_elem_path = null;
	Dict drag_start_point = null;
	string drag_dest_box = null;
	string drag_dest_kind = "";
	Vector drag_dest_path = null;
	var drag_dest_elem = null;
	TreeModel model = null;
	
	
	/**
	 * Find drag elem
	 */
	var findDragElem(var elem)
	{
		if (elem.classList.contains("tree_widget__item_label")) return elem.parentElement;
		return elem;
	}
	
	
	/**
	 * Find elem by path
	 */
	var findElemByPath(var path)
	{
		path = ".tree_widget__item[data-path='" ~ path ~ "']";
		return document.querySelector(path);
	}
	
	
	/**
	 * Returns true if elem inside drag_elem
	 */
	void checkInside(Vector path)
	{
		if (not this.drag_elem_path) return false;
		
		string drag_elem_path = rs::join(".", this.drag_elem_path);
		string elem_path = path ? rs::join(".", path) : "";
		
		if (drag_elem_path == elem_path) return false;
		if (rs::substr(elem_path, 0, rs::strlen(drag_elem_path) + 1) == drag_elem_path ~ ".")
		{
			return true;
		}
		return false;
	}
	
	
	/**
	 * Returns true if path is equal
	 */
	static bool equalPath(Vector src_path, Vector dest_path)
	{
		string src_elem = src_path ? rs::join(".", src_path) : "";
		string dest_elem = dest_path ? rs::join(".", dest_path) : "";
		return src_elem == dest_elem;
	}
	
	
	/**
	 * Returns true if can drag
	 */
	bool canDrag(Vector src_path, Vector dest_path, string kind)
	{
		return true;
	}
	
	
	/**
	 * Drag element
	 */
	void dragElement(Vector src_path, Vector dest_path, string kind)
	{
	}
	
	
	/**
	 * Set start drag item
	 */
	void onMouseDownItem(var e, Vector path)
	{
		this.drag_elem = this.findDragElem(e.currentTarget);
		this.drag_elem_path = path.slice();
		this.drag_start_point = {
			"x": e.layerX,
			"y": e.layerY,
		};
	}
	
	
	/**
	 * Mouse move item
	 */
	void onMouseMoveItem(var e, Vector path)
	{
		if (this.drag_elem == null) return;
		
		/* Try to start drag & drop */
		if (not this.is_drag) this.startDrag(e);
		if (not this.is_drag) return;
		
		/* Drag & Drop started */
		var target = this.findDragElem(e.currentTarget);
		int top = target.offsetTop;
		int bottom = target.offsetTop + target.clientHeight;
		int center = (top + bottom) / 2;
		
		/* Get kind */
		string kind = static::DRAG_BEFORE;
		if (e.layerY >= center)
		{
			kind = static::DRAG_INTO;
		}
		
		/* Set drag target */
		this.setTarget(target, path, kind);
		e.preventDefault();
	}
	
	
	/**
	 * On mouse move
	 */
	void onMouseMove(var e)
	{
		if (this.drag_elem == null) return;
		
		/* Try to start drag & drop */
		if (not this.is_drag) this.startDrag(e);
		if (not this.is_drag) return;
		
		/* Outside of tree contents */
		var tree_content = this.component.getRef("content");
		if (e.layerY > tree_content.clientHeight)
		{
			this.setTarget(tree_content, null, static::DRAG_AFTER);
			e.preventDefault();
			return false;
		}
	}
	
	
	/**
	 * Start Drag & Drop
	 */
	void startDrag(var e)
	{
		if (this.is_drag != false) return false;
		if (this.drag_start_point == null) return false;
		if (Math::abs(e.layerY - this.drag_start_point.get("y")) > 5) return false;
		this.is_drag = true;
		return true;
	}
	
	
	/**
	 * Stop drag & drop
	 */
	void stopDrag()
	{
		/* Do drag & drop */
		if (this.drag_dest_box)
		{
			this.dragElement(this.drag_elem_path, this.drag_dest_path, this.drag_dest_kind);
		}
		
		this.is_drag = false;
		this.drag_dest_box = null;
		this.drag_dest_elem = null;
		this.drag_dest_path = null;
		this.drag_dest_kind = null;
		this.drag_elem = null;
		this.drag_elem_path = null;
		this.drag_start_point = null;
	}
	
	
	/**
	 * Set drag & drop dest element
	 */
	void setTarget(var elem, Vector path, string kind)
	{
		if (not this.is_drag) return;
		
		string src_path = rs::join(".", this.drag_elem_path);
		string dest_path = path ? rs::join(".", path) : "";
		
		TreeItem item = this.model.root.get(path);
		if (this.checkInside(path)) return;
		if (kind == "into" and src_path == dest_path) kind = "before";
		if (kind == "into" and item != null and not item.canDragInside()) kind = "after";
		if (static::equalPath(this.drag_dest_path, path) and
			this.drag_dest_kind == kind) return;
		
		/* Setup dest element */
		this.drag_dest_elem = elem;
		this.drag_dest_path = path;
		
		/* Can drag */
		bool can_drag = this.canDrag(this.drag_elem_path, this.drag_dest_path, kind);
		
		/* Set dest kind */
		this.drag_dest_kind = kind;
		
		/* Setup dest box */
		if (src_path != dest_path and can_drag) this.drag_dest_box = this.getBoxStyles(elem, kind);
		else this.drag_dest_box = null;
	}
	
	
	/**
	 * Returns box styles by element
	 */
	Dict getBoxStyles(var elem, string kind = "")
	{
		int left, top, width, height;
		
		left = elem.offsetLeft;
		top = elem.offsetTop;
		width = elem.clientWidth - 1;
		height = elem.clientHeight - 1;
		
		if (kind == static::DRAG_BEFORE) return rs::join(";", [
			"left: " ~ left ~ "px",
			"top: " ~ top ~ "px",
			"width: " ~ width ~ "px",
			"height: 1px",
		]);
		
		if (kind == static::DRAG_AFTER) return rs::join(";", [
			"left: " ~ left ~ "px",
			"top: " ~ (top + height) ~ "px",
			"width: " ~ width ~ "px",
			"height: 1px",
		]);
		
		if (kind == static::DRAG_INTO) return rs::join(";", [
			"left: " ~ left ~ "px",
			"top: " ~ top ~ "px",
			"width: " ~ width ~ "px",
			"height: " ~ height ~ "px",
		]);
		
		return null;
	}
}